package Test::DBIx::Class;

use 5.008;
use strict;
use warnings;

use base 'Test::Builder::Module';

our $VERSION = '0.01';
our $AUTHORITY = 'cpan:JJNAPIORK';

use Test::DBIx::Class::Schema;
use Path::Class;
use Config::Any;
use Hash::Merge;
use Sub::Exporter;
use Test::More ();
use Scalar::Util 'blessed';

sub import {
	my ($class, @opts) = @_;
	my ($schema_manager, @exports) = $class->_initialize(@opts);
	
	my $exporter = Sub::Exporter::build_exporter({
		exports => [
			Schema => sub {
				return sub {
					return $schema_manager->schema;
				}
			},
			ResultSet => sub {
				my ($local_class, $name, $arg) = @_;
				return sub {
					my $source = shift @_;
					my $search = shift @_;
					my $resultset = $schema_manager->schema->resultset($source);

					if(my $global_search = $arg->{search}) {
						my @global_search = ref $global_search eq 'ARRAY' ? @$global_search : ($global_search);
						$resultset = $resultset->search(@global_search);
					}

					if($search) {
						my @search = ref $search ? @$search : ($search, @_);
						$resultset = $resultset->search(@search);
					}

					return $resultset;
				}
			},
			is_result => sub {
				return sub {
					my $rs = shift @_;
					my $compare = shift @_ || "DBIx::Class";
					my $message = shift @_;
					Test::More::isa_ok($rs, $compare, $message);
				}
			},
			is_resultset => sub {
				return sub {
					my $rs = shift @_;
					my $compare = shift @_ || "DBIx::Class::ResultSet";
					my $message = shift @_;
					Test::More::isa_ok($rs, $compare, $message);
				}
			},
			eq_result => sub {
				return sub {
					my ($result1, $result2, $message) = @_;
					$message = defined $message ? $message : ref($result1) . " equals " . ref($result2);
					if( ref($result1) eq ref($result2) ) {
						Test::More::is_deeply(
							{$result1->get_columns},
							{$result2->get_columns},
							$message,
						);
					} else {
						Test::More::fail($message ." :Result arguments not of same class");
					}
				},
			},
			eq_resultset => sub {
				return sub {
					my ($rs1, $rs2, $message) = @_;
					$message = defined $message ? $message : ref($rs1) . " equals " . ref($rs2);
					if( ref($rs1) eq ref($rs2) ) {
						($rs1, $rs2) = map {
							my @pks = $_->result_source->primary_columns;
							my @result = $_->search({}, {
								result_class => 'DBIx::Class::ResultClass::HashRefInflator',
								order_by => [@pks],
							})->all;
							[@result];
						} ($rs1, $rs2);

						Test::More::is_deeply([$rs1],[$rs2],$message);
					} else {
						Test::More::fail($message ." :ResultSet arguments not of same class");
					}
				},
			},
			hri_dump => sub {
				return sub {
					(shift)->search ({}, {
						result_class => 'DBIx::Class::ResultClass::HashRefInflator'
					});
				}
			},
			fixtures_ok => sub {
				return sub {
					my ($arg, $message) = @_;
					$message = defined $message ? $message : 'Fixtures Installed';

					if ($arg && ref $arg && (ref $arg eq 'CODE')) {
						eval {
							$arg->($schema_manager->schema);
						}; if($@) {
							Test::More::fail($message);
							$schema_manager->builder->diag($@);

						} else {
							Test::More::pass($message);
						}
					} elsif( $arg && ref $arg && (ref $arg eq 'HASH') ) {
						eval {
							$schema_manager->install_fixtures($arg);
						}; if($@) {
							Test::More::fail($message);
							$schema_manager->builder->diag($@);
						} else {
							Test::More::pass($message);
						}
					} elsif( $arg ) {
						my @sets = ref $arg ? @$arg : ($arg);
						my @fixtures = $schema_manager->get_fixture_sets(@sets);
						foreach my $fixture (@fixtures) {
							eval {
								$schema_manager->install_fixtures($fixture);
							}; if($@) {
								Test::More::fail($message);
								$schema_manager->builder->diag($@);
							} else {
								Test::More::pass($message);
							}
						}
					} else {
						Test::More::fail("Can't figure out what fixtures you want");
					}
				}
			},
			is_fields => sub {
				my ($local_class, $name, $arg) = @_;
				my @default_fields = ();
				if(defined $arg && ref $arg eq 'HASH' && defined $arg->{fields}) {
					@default_fields = ref $arg->{fields} ? @{$arg->{fields}} : ($arg->{fields});
				}
				return sub {
					my @args = @_;
					my @fields = @default_fields;
					if(!ref($args[0]) || (ref($args[0]) eq 'ARRAY')) {
						my $fields = shift(@args);
						@fields = ref $fields ? @$fields : ($fields); 
					} 
					if(blessed $args[0] && $args[0]->isa('DBIx::Class')) {
						my $result = shift(@args);
						unless(@fields) {
							my @pks = $result->result_source->primary_columns;
							push @fields, grep {
								my $field = $_; 
								$field ne ((grep { $field eq $_ } @pks)[0] || '')
							} ($result->result_source->columns);
						}
						my $compare = shift(@args);
						if(ref $compare eq 'HASH') {
						} elsif(ref $compare eq 'ARRAY') {
							my @localfields = @fields;
							$compare = {map {
								my $value = $_;
								my $key = shift(@localfields);
								$key => $value } @$compare};
							Test::More::fail('Too many fields!') if @localfields;
						} elsif(!ref $compare) {
							my @localfields = @fields;
							$compare = {map {
								my $value = $_;
								my $key = shift(@localfields);
								$key => $value } ($compare)};
							Test::More::fail('Too many fields!') if @localfields;
						}
						my $message = shift(@args) || 'Fields match';
						my $compare_rs = {map {
							die "$_ is not an available field"
							  unless $result->can($_); 
							$_ => $result->$_ } @fields};
						Test::More::is_deeply($compare_rs,$compare,$message);
						return $compare;
					} elsif (blessed $args[0] && $args[0]->isa('DBIx::Class::ResultSet')) {
#						my @sets;
#						if(blessed $args[0]) {
#							my $resultset = shift @args;
#							my $compare = shift @args;
#							@sets = ({$result=>$compare});
#						} elsif(ref $args[0] eq 'ARRAY') {
#							my @localargs = @{shift @args};
#							while(@localargs) {
#								my $resultset = shift @localargs;
#								my $compare = shift @localargs;
#								push @sets, {$result=>$compare};
#							}
#						}
#						foreach my $set(@sets) {
#							my ($resultset, $compare) = %$set;
#							my @compare = @$compare
#							if(ref $compare eq '') {
#							} elsif(ref $compare eq 'ARRAY') {
#								my @localfields = @fields;
#								$compare = {map {
#									my $value = $_;
#									my $key = shift(@localfields);
#									$key => $value } @$compare};
#								Test::More::fail('Too many fields!') if @localfields;
#							} elsif(!ref $compare) {
#								my @localfields = @fields;
#								$compare = {map {
#									my $value = $_;
#									my $key = shift(@localfields);
#									$key => $value } ($compare)};
#								Test::More::fail('Too many fields!') if @localfields;
#							}
#							my $message = shift(@args) || 'Fields match';
#						}

					}
				};
			},
			reset_schema => sub {
				return sub {
					my $message = shift @_ || 'Schema reset complete';
					$schema_manager->reset;
					Test::More::pass($message);
				}
			},
			map {
				my $source = $_;
 				$source => sub {
					my ($local_class, $name, $arg) = @_;
					my $resultset = $schema_manager->schema->resultset($source);
					if(my $search = $arg->{search}) {
						my @search = ref $search eq 'ARRAY' ? @$search : ($search);
						$resultset = $resultset->search(@search);
					}
					return sub {
						my $search = shift @_;
						if($search) {
							my @search = ();
							if(ref $search && ref $search eq 'HASH') {
								@search = ($search, @_); 
							} else {
								@search = ({$search, @_});
							}
							return $resultset->search(@search);
						}
						return $resultset;
					}
				};
			} $schema_manager->schema->sources,
		],
		groups => {
			resultsources => [$schema_manager->schema->sources],
		},
		into_level => 1,	
	});



	$class->$exporter(
		qw/Schema ResultSet is_result is_resultset hri_dump fixtures_ok reset_schema
			eq_result eq_resultset is_fields/,
		 @exports
	);
		
}

sub _initialize {
	my ($class, @opts) = @_;
	my ($config, @exports) = $class->_normalize_opts(@opts);
	my $merged_config = $class->_prepare_config($config);
	my $merged_with_fixtures_config = $class->_prepare_fixtures($merged_config);

	return (
		$class->_initialize_schema($merged_with_fixtures_config),
		@exports,
	);
}

sub _normalize_opts {
	my ($class, @opts) = @_;
	my ($config, @exports) = ({},());

	if(ref $opts[0]) {
		if(ref $opts[0] eq 'HASH') {
			$config = shift(@opts);
		} else {
			die 'First argument to "use Test::DBIx::Class @args" not properly formed.';
		}
	}

	while( my $opt = shift(@opts)) {
		if($opt =~m/^-(.+)/) {
			if($config->{$1}) {
				die "$1 already is defined as $config->{$1}";
			} else {
				$config->{$1} = shift(@opts);
			}
		} else {
			@exports = ($opt, @opts);
			last;
		}
	}

	if(my $resultsources = delete $config->{resultsources}) {
		if(ref $resultsources eq 'ARRAY') {
			push @exports, @$resultsources;
		} else {
			die '"resultsources" options must be a Array Reference.';
		}
	}
	
	return ($config, @exports);
}

sub _prepare_fixtures {
	my ($class, $config) = @_;

	my @dirs;
	if(my $fixture_path = delete $config->{fixture_path}) {
		@dirs = $class->_normalize_config_path(
			$class->_default_fixture_paths, $fixture_path, 
		);
	} else {
		@dirs = $class->_normalize_config_path($class->_default_fixture_paths);
	}

		my @extensions = $class->_allowed_extensions;
		my @files = grep { $class->_is_allowed_extension($_) }
			map {Path::Class::dir($_)->children} 
			grep { -e $_  } @dirs;

		my $fixture_definitions = Config::Any->load_files({
			files => \@files,
			use_ext => 1,
		});

		my %merged_fixtures;
		foreach my $fixture_definition(@$fixture_definitions) {
			my ($path, $fixture) = each %$fixture_definition;
			my $file = Path::Class::file($path)->basename;
			$file =~s/\..{1,4}$//;
			if($merged_fixtures{$file}) {
				$merged_fixtures{$file} = Hash::Merge::merge($fixture, $merged_fixtures{$file});
			} else {
				$merged_fixtures{$file} = $fixture;
			}
		}

		if(my $old_fixture_sets = delete $config->{fixture_sets}) {
			my $new_fixture_sets = Hash::Merge::merge($old_fixture_sets, \%merged_fixtures );
			$config->{fixture_sets} = $new_fixture_sets;
		} else {
			$config->{fixture_sets} = \%merged_fixtures;
		}

	return $config;
}

sub _is_allowed_extension {
	my ($class, $file) = @_;
	my @extensions = $class->_allowed_extensions;
	foreach my $extension(@extensions) {
		if($file =~ m/\.$extension$/) {
			return $file;
		}
	}
	return;
}

sub _prepare_config {
	my ($class, $config) = @_;

	if(my $extra_config = delete $config->{config_path}) {
		my @config_data = $class->_load_via_config_any($extra_config);
		foreach my $config_datum(reverse @config_data) {
			$config = Hash::Merge::merge($config, $config_datum);
		}
	} else {
		my @config_data = $class->_load_via_config_any();
		foreach my $config_datum(reverse @config_data) {
			$config = Hash::Merge::merge($config, $config_datum);
		}
	}
	return $config;
}

sub _load_via_config_any {
	my ($class, $extra_paths) = @_;
	my @files = $class->_valid_config_files($class->_default_paths, $extra_paths);

    my $config = Config::Any->load_files({
		files => \@files,
		use_ext => 1,
	});

	my @config_data = map { values %$_ } @$config;
	return @config_data;
}

sub _valid_config_files {
	my ($class, $default_paths, $extra_paths) = @_;
	my @extensions = $class->_allowed_extensions;
	my @paths = $class->_normalize_config_path($default_paths, $extra_paths);
	my @config_files = grep { -e $_} map { 
		my $path = $_; 
		map {"$path.$_"} @extensions;
	 } @paths;

	return @config_files;
}

sub _allowed_extensions {
	return @{ Config::Any->extensions };
}

sub _normalize_config_path {
	my ($class, $default_paths, $extra_paths) = @_;

	##use Data::Dump 'dump'; die dump @$extra_paths;

	if(defined $extra_paths) {
		my @extra_paths = ref $extra_paths ? @$extra_paths : ($extra_paths);
		@extra_paths = map { "$_" eq "+" ? @$default_paths : $_ } map {
			my @local_path = ref $_ ? @$_ : ($_);
			Path::Class::file(@local_path);
		} @extra_paths;

		return @extra_paths;	
	} else {
		return @$default_paths;
	}
}

sub _script_path {
	return ($0 =~m/^(.+)\.t$/)[0];
}

sub _default_fixture_paths {
	my ($class) = @_;
	my $script_path = Path::Class::file($class->_script_path);
	my $script_dir = $script_path->dir;
	my @dir_parts = $script_dir->dir_list(1);

	return [
		Path::Class::file(qw/t etc fixtures/),
		Path::Class::file(qw/t etc fixtures/, @dir_parts, $script_path->basename),
	];

}

sub _default_paths {
	my ($class) = @_;
	my $script_path = Path::Class::file($class->_script_path);
	my $script_dir = $script_path->dir;
	my @dir_parts = $script_dir->dir_list(1);

	return [
		Path::Class::file(qw/t etc schema/),
		Path::Class::file(qw/t etc /, @dir_parts, $script_path->basename),
	];
}

sub _initialize_schema {
	my $class = shift @_;
	my $config  = shift @_;
	my $builder = __PACKAGE__->builder;

	return Test::DBIx::Class::Schema->initialize_schema(
		%$config, 
		builder => $builder,
	);
}

1;

__END__

=head1 NAME

Test::DBIx::Class - Easier test cases for your L<DBIx::Class> applications

=head1 SYNOPSIS

The following is example usage for this module.  Assume you create a standard
Perl testing script, such as "MyApp/t/schema/01-basic.t" which is run from the
shell like "prove -l t/schema/01-basic.t" or during "make test".  That test 
script would contain:

	use Test::More; {

		use strict;
		use warnings;

		use Test::DBIx::Class {
			schema_class => 'MyApp::Schema',
			connect_info => ['dbi:SQLite:dbname=:memory:','',''],
			fixture_class => '::Populate',
			fixture_providers => [
				'::File' => {
					path => [ 
						[qw/t etc fixtures/], 
						[qw/t etc schema 01-basic/], 
					],
				},
			],
		}, 'Person', 'Person::Employee' => {-as => 'Employee'}, 'Job', 'Phone';

		## Your testing code below ##

		## Your testing code above ##

		done_testing();
	}

Yes, it looks like a lot of boilerplate, but sensible defaults are in place 
(the above code example shows most of the existing defaults) and configuration
data can be loaded from a central file.  So your 'real life' example is going
to look closer to (assuming you put all your test configuration in the standard
place, "t/etc/schema.conf":

	use Test::More; {
		
		use strict;
		use warnings;
		use Test::DBIx::Class;

		## Your testing code below ##
		## Your testing code above ##

		done_testing();
	}

Then, assuming the existance of a L<DBIx::Class::Schema> subclass called, 
"MyApp::Schema" and some L<DBIx::Class::ResultSources> named like "Person", 
"Person::Employee", "Job" and "Phone", will automatically deploy a testing 
schema in the given database / storage, install fixtures and let you run some
test cases, such as:

		## Your testing code below ##

		fixtures_ok 'basic'
		  => 'installed the basic fixtures from configuration files';

		fixtures_ok { 
			Job => [
				[qw/name description/],
				[Programmer => 'She whow writes the code'],
				['Movie Star' => 'Knows nothing about the code'],
			],
		}, 'Installed some custom fixtures via the Populate fixture class',

		
		ok my $john = Person->find({email=>'jjnapiork@cpan.org'})
		  => 'John has entered the building!';

		is_result $john->employee, Employee->find($john->id)
		  => "John belongs to Employee";

		is_resultset $john->jobs, Job->search({job_title=>[qw/Programmer Administrator/]})
		  => 'John has both the Programmer and Administrator Jobs';

		is_fields $john, {
			name => 'John Napiorkowski', 
			email => 'jjnapiork@cpan.org', 
			age => 40,
		}, 'John has the expected fields';

		is_fields $john->jobs, [
			{job_title => 'programmer'},
			{job_title => 'administrator'},
		];

		is_fields 'job_title', $john->jobs, 
			[qw/programmer administrator/];

		is_fields [qw/job_title salary/], $john->jobs, [
			['programmer', 100000],
			['administrator, 120000],
		], 'Got expected fields from $john->jobs';

		is_fields [qw/name age/], $john, ['John Napiorkowski', 40],
		  => 'John has expected name and age';

		is_fields 'name', [
			$john, ['John Napiorkowski'],
			$vanessa, ['Vanessa Li'],
			$vincent, ['Vincent Zhou'],
		] => 'All names as expected';

		is_fields 'fullname', 
			ResultSet('Country')->find('USA'), 
			'United States of America',
			'Found the USA';

		is_deeply [sort Schema->sources], [qw/
			Person Person::Employee Job Country Phone
		/], 'Found all expected sources in the schema';

		fixtures_ok my $first_album = sub {
			my $schema = shift @_;
			my $cd_rs = $schema->resultset('CD');
			return $cd_rs->create({
				name => 'My First Album',
				track_rs => [
					{position=>1, title=>'the first song'},
					{position=>2, title=>'yet another song'},
				],
				cd_artist_rs=> [
					{person_artist=>{person => $vanessa}},
					{person_artist=>{person => $john}},
				],
			});
		}, 'You can even use a code reference for custom fixtures';

		is_fields {
			name => 'My First Album',
			track_rs => [
				{ title=>'the first song' },
				{ title=>'yet another song'},
			],
			artists => [
				{person => $vanessa},
				{person => john},
			],
		}, $first_album, "Expected Data exists in the created CD";

		diag last_query();

		## Your testing code above ##

Please see the test cases for more examples.

=head1 DESCRIPTION

The goal of this distribution is to make it easier to write test cases for your
L<DBIx::Class> based applications.  It does this in three ways.  First, it trys
to make it easy to deploy your Schema to a test sandbox.  This can be to your
dedicated testing database, a simple SQLite database, or even a MySQL Sandbox.
This allows you to run tests without interfering with your development work.

Second, we allow you to load test fixtures via several different tools.  Last
we create some helper functions in your test script so that you can reduce
repeated or boilerplate code.

Overall, we attempt to reduce the amount of code you have to write before you
can begin writing tests.

=head1 IMPORTED METHODS

The following methods are automatically imported when you use this module.

=head2 Schema

You probably won't need this directly in your tests unless you have some
application logic methods in it.


=head2 ResultSet ($source, ?{%search}, ?{%conditions})

Although you can import your sources as local keywords, sometimes you might
need to get a particular resultset when you don't wish to import is globally.
Use like

	ok ResultSet('Job'), "Yeah, some jobs in the database";
	ok ResultSet( Job => {hourly_pay=>{'>'=>100}}), "Good paying jobs available!";

Since this returns a normal L<DBIx::Class::ResultSet>, you can just call the
normal methods against it.

	ok ResultSet('Job')->search({hourly_pay=>{'>'=>100}}), "Good paying jobs available!";

This is the same as the test above

=head2 fixtures_ok

This is used to install and verify installation of fixtures, either inlined,
from a fixture set in a file, or through a custom sub reference.  Accept three
argument styles:

=over 4

=item coderef

Given a code reference, execute it against the currently defined schema.  This
is used when you need a lot of control over installing your fixtures.  Example:

	fixtures_ok sub {
		my $schema = shift @_;
		my $cd_rs = $schema->resultset('CD');
		return $cd_rs->create({
			name => 'My First Album',
			track_rs => [
				{position=>1, title=>'the first song'},
				{position=>2, title=>'yet another song'},
			],
			cd_artist_rs=> [
				{person_artist=>{person => $vanessa}},
				{person_artist=>{person => $john}},
			],
		});

	}, 'Installed fixtures';

The above gets executed at runtime and if there is an error it is trapped,
reported and we move on to the next test.

=back

=head2 is_result ($result, ?$result)

Quick test to make sure $result does inherit from L<DBIx::Class> or that it
inherits from a subclass of L<DBIx::Class>.

=head2 is_resultset ($resultset, ?$resultset)

Quick test to make sure $resultset does inherit from L<DBIx::Class::ResultSet>
or from a subclass of L<DBIx::Class::ResultSet>.

=head2 eq_resultset ($resultset, $resultset, ?$message)

Given two ResultSets, determine if the are equal based on class type and data.
This is a true set equality that ignores sorting order of items inside the
set.

=head2 eq_result ($resultset, $resultset, ?$message)

Given two row objects, make sure they are the same.

=head2 hri_dump ($resultset)

Not a test, just returns a version of the ResultSet that has its inflator set
to L<DBIx::Class::ResultClass::HashRefInflator>, which returns a set of hashes
and makes it easier to stop issues.

=head2 is_fields

	TBD

=head1 SETUP AND INITIALIZATION

The generic usage for this would look like one of the following:

	use Test::DBIx::Class \%options, @sources
	use Test::DBIx::Class %options, @sources

Where %options are key value pairs and @sources an array as specified below.

=head2 Initialization Options

The only difference between the hash and hash reference version of %options
is that the hash version requires its keys to be prepended with "-".  If
you are inlining a lot of configuration the hash reference version may look
neater, while if you are only setting one or two options the hash version
might be more readable.  For example, the following are the same:

	use Test::DBIx::Class -config_path=>[qw(t etc config)], 'Person', 'Job';
	use Test::DBIx::Class {config_path=>[qw(t etc config)]}, 'Person', 'Job';

The following options are currently defined.

=over 4

=item config_path

These are the relative paths searched for configuration file information. See
L</Initialization Sources> for more.

In the case were we have both inlined and file based configurations, the 
inlined is merged last (that is, has highest authority to override configuration
files.

=item schema_class

Required.  If left blank, will look down the lib path for a module called,
"Schema.pm" or "Store.pm" and attempt to use that.

=item connect_info

Required. This will accept anything you can send to L<DBIx::Class/connect>.
Defaults to: ['dbi:SQLite:dbname=:memory:','',''] if left blank.

=item fixture_path

These are a list of relative paths search for fixtures.  Each item should be
a directory that contains files loadable by L<Config::Any> and suitable to
be installed via one of the fixture classes.

=item fixture_class

Command class that installs data into the database.  Must provide a method
called 'install_fixtures' that accepts a perl data structure and installs
it into the database.  Must capture and report errors.  Default value is
"::Populate", which loads L<Test::DBIx::Class::FixtureClass::Populate>, which
is a command class based on L<DBIx::Class::Schema/populate>.

=item resultsources

Lets you add in some result source definitions to be imported at test script
runtime.  See L</Initialization Sources> for more.

=back

=head2 Initialization Sources

The @sources are a list of result sources that you want helper methods injected
into your test script namespace.  This is the 'Source' part of:

	$schema->resultset('Source');

Injecting methods are optional since you can also use the 'ResultSet' keyword

Imported Source keywords use L<Sub::Exporter> so you have quite a few options
for controling how the keywords are imported.  For example:

	use Test::DBIx::Class 
		'Person',
		'Person::Employee' => {-as => 'Employee'},
		'Person' => {search => {age=>{'>'=>55}}, -as => 'OlderPerson'};

This would import three local keywork methods, "Person", "Employee" and 
"OlderPerson".  For "OlderPerson", the search parameter would automatically be
resolved via $resultset->search and the correct resultset returned.  You may
wish to preconfigure all your test result set cases in one go at the top of
your test script as a way to promote reusability.

Additionally, since you can also initialize sources via the 'resultsources'
configuration option, which can be placed into your global configuration files
this means you can predefine and result resultsets across all your tests.

=head1 CONFIGURATION BY FILE

By default, we try to load a configuration file at the following locations:

	 ./t/etc/schema.*
	 ./t/etc/[test file path].*

Where "." is the root of the distribution and "*" is any of the configuration
file types supported by L<Config::Any> configuration loader.  This allows you
to store configuration in the format of your choice.

"[test file path]" is the relative path part under the "t" directory of the
calling test script.  For example, if your test script is "t/mytest.t" we add
the path "./t/etc/schema/mytest.*" to the path.

Additionally, we do a a merge using L<Hash::Merge> of all the matching found
configurations.  This allows you to do 'cascading' configuration from the most
global to the most local settings.

You can override this search path with the "-config_path" key in options. For
example, the following searches for "t/etc/myconfig.*" (or whatever is the
correct directory separator for your operating system):

	use Test::DBIx::Class -config_path => [qw/t etc myconfig/];

Relative paths are rooted to the distribution home directory (ie, the one that
contains your 'lib' and 't' directories).  Full paths are searched without
modification.

You can specify multiply paths.  The following would search for both "schema.*"
and "share/schema".

	use Test::DBIx::Class -config_path => [[qw/share schema/], [qw/schema/]];

Lastly, you can use the special symbol "+" to indicate that your custom path
adds to or prepends to the default search path.  Since as indicated we merge
all the configurations found, this means it's easy to create user level 
configuration settings mixed with global settings, as in:

	use Test::DBIx::Class
		-config_path => [ 
			[qw(/ etc myapp test-schema)],
			'+',
			[qw(~ etc test-schema)],
		];

Which would search and combine "/etc/myapp/test-schema.*", "./t/etc/schema.*",
"./etc/test-dbix-class.*" and "~/etc/test-schema.*".  This would let you set
up server level global settings, distribution level settings and finally user
level settings.

Please note that in all the examples given, paths are written as an array
reference of path parts, rather than as a string with delimiters (i.e. we do
[qw(t etc)] rather than "t/etc").  This is not required but recommended.  All
arguments, either string or array references, are passed to L<Path::Class> so
that we can maintain better compatibility with non unix filesystems.  

Your configuration should inflate to a Perl structure that is a hash or hash
reference.  The following keys are supported / required.

=head1 EXAMPLES

The following are some examples using this module.

	TBD

=head1 SEE ALSO

The following modules or resources may be of interest.

L<DBIx::Class>, L<DBIx::Class::Schema::PopulateMore>, L<DBIx::Class::Fixtures>

=head1 AUTHOR

John Napiorkowski C<< <jjnapiork@cpan.org> >>

=head1 COPYRIGHT & LICENSE

Copyright 2009, John Napiorkowski C<< <jjnapiork@cpan.org> >>

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
